package gowriter

const appTemplate string = `// Code generated by clic; DO NOT EDIT.

package main

import (
	"fmt"
	"log"
	"io"
	"net/http"
	"os"
	"os/exec"
	"strings"

	"github.com/spf13/cobra"
)

func main() {
	rootCmd := &cobra.Command{
		Use: "{{.Name}}",
	}
	{{range .Commands -}}
	{{$cmd := .}}
	{{- $cmd.Name}}_cmd := &cobra.Command{
		Use:   "{{.Name}}",
		Short: "{{.Name}}",
		Args:  cobra.MinimumNArgs({{.NArgs}}),
{{- with .Exec}}
		{{- $exec := .}}
		Run: func(cmd *cobra.Command, argValues []string) {
			path := "{{.Path}}"
			execArgs := []string{
				{{range $i, $execArg := .Args -}}
				"{{.}}",
				{{end}}
			}

			// parameterize exec path and each exec arg with arg values
			{{- range $argIndex, $arg := $cmd.Args}}
			path = strings.ReplaceAll(path, "{params.{{$arg.Name}}}", argValues[{{$argIndex}}])
			{{- range $execArgIndex, $execArgValue := $exec.Args}}
			execArgs[{{$execArgIndex}}] = strings.ReplaceAll(execArgs[{{$execArgIndex}}], "{params.{{$arg.Name}}}", argValues[{{$argIndex}}])
			{{end -}}
			{{end}}

			// parameterize exec path and each exec arg with flag values
			var flagVal string
			{{- range $flagIndex, $flag := $cmd.Flags}}
			flagVal, _ = cmd.Flags().Get{{$flag.Type}}("{{$flag.Name}}")
			path = strings.ReplaceAll(path, "{params.{{$flag.Name}}}", flagVal)
			{{- range $execArgIndex, $execArgValue := $exec.Args}}
			execArgs[{{$execArgIndex}}] = strings.ReplaceAll(execArgs[{{$execArgIndex}}], "{params.{{$flag.Name}}}", flagVal)
			{{end -}}
			{{end}}
			doexec(path, execArgs)
		},
{{- end}}
{{- with .REST}}
		{{- $rest := .}}
		Run: func(cmd *cobra.Command, argValues []string) {
			method := "{{.Method}}"
			endpoint := "{{.Endpoint}}"
			dorest(method, endpoint, {{if .NoStatus}}false{{else}}true{{end}})
		},
{{- end}}
	}

	{{range .Flags -}}
	{{$cmd.Name}}_cmd.Flags().{{.Type}}("{{.Name}}", "{{.Default}}", "{{.Description}}")
	{{end -}}
	
	rootCmd.AddCommand({{$cmd.Name}}_cmd)

	{{end -}}

	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func doexec(path string, args []string) {
	command := exec.Command(path, args...)
	command.Env = os.Environ()
	command.Stdin = os.Stdin
	command.Stdout = os.Stdout
	command.Stderr = os.Stderr

	if err := command.Run(); err != nil {
		if exitError, ok := err.(*exec.ExitError); ok {
			os.Exit(exitError.ExitCode())
		}

		os.Exit(1)
	}

	os.Exit(0)
}

func dorest(method string, endpoint string, printStatus bool) {
	client := http.Client{}
	request, err := http.NewRequest(method, endpoint, nil)
	if err != nil {
		log.Fatalln(err)
	}

	response, err := client.Do(request)
	if err != nil {
		log.Fatalln(err)
	}

	if printStatus {
		fmt.Fprintln(os.Stdout, response.Status)
	}

	defer response.Body.Close()
	io.Copy(os.Stdout, response.Body)
}

// TODO: remove this hack that satisfies the "strings" import usage when no parameters are being replaced
func hack() strings.Builder {
	return strings.Builder{}
}
`
